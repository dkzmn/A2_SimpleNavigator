# SimpleNavigator

Реализация проекта Simple Navigator.

В рамках данного задания все графы должны удовлетворять следующим требованиям:
- Веса ребер только натуральными числами.
- Могут быть петли.
- Веса могут отличаться на всех ребрах.
- Только ненулевой связный граф.

## Part 1. Обход графа в глубину и в ширину

Реализуй библиотеку _s21_graph.h_:
* Библиотека должна быть разработана на языке С++ стандарта C++17.
* Код библиотеки должен находиться в папке src в ветке develop.
* При написании кода придерживайся Google Style.
* Оформи решение как статическую библиотеку (с заголовочным файлом _s21_graph.h_).
* Библиотека должна быть представлена в виде класса `Graph`, который хранит в себе информацию о графе с помощью **матрицы смежности**. Размерность матрицы смежности должна задаваться динамически при инициализации графа (при его загрузке из файла).
* Сборка программы должна быть настроена с помощью Makefile со стандартным набором целей для GNU-программ: _all, clean, test, s21_graph.a_.
* Должно быть обеспечено полное покрытие unit-тестами методов класса `Graph`.
* Класс `Graph` должен содержать в себе по крайней мере следующие публичные методы:
    + `LoadGraphFromFile(string filename)` - загрузка графа из файла в формате матрицы смежности.
    + `ExportGraphToDot(string filename)` - выгрузка графа в файл в формате dot (см. материалы).

Реализуй библиотеку _s21_graph_algorithms.h_:
* Библиотека должна быть разработана на языке С++ стандарта C++17.
* Код библиотеки должен находиться в папке src в ветке develop.
* Оформи решение как статическую библиотеку (с заголовочным файлом _s21_graph_algorithms.h_).
* Библиотека должна быть представлена в виде класса `GraphAlgorithms`, который будет содержать в себе реализацию алгоритмов на графах. При этом сам класс `GraphAlgorithms` не должен ничего знать о внутреннем представлении графа из класса `Graph`. Для взаимодействия с данными графа класс `GraphAlgorithms` может использовать только публичные методы и свойства, предоставляемые классом `Graph`.
* Добавить в Makefile цель _s21_graph_algorithms.a_.
* Должно быть обеспечено полное покрытие unit-тестами методов класса `GraphAlgorithms`.
* Класс `GraphAlgorithms` должен содержать в себе по крайней мере следующие публичные методы:    
    + `DepthFirstSearch(Graph &graph, int start_vertex)` - *нерекурентный* поиск в глубину в графе от заданной вершины. Функция должна возвращать массив, содержащий в себе обойдённые вершины в порядке их обхода. При реализации этой функции обязательно используй *самописную* структуру данных **стек**, которую предварительно стоит оформить в виде отдельной статической библиотеки.
    + `BreadthFirstSearch(Graph &graph, int start_vertex)` - поиск в ширину в графе от заданной вершины. Функция должна возвращать массив, содержащий в себе обойдённые вершины в порядке их обхода. При реализации этой функции обязательно используй *самописную* структуру данных **очередь**, которую предварительно стоит оформить в виде отдельной статической библиотеки.
* Необходимо использовать *самописные* вспомогательные классы `Stack` и `Queue` (для этого можешь переиспользовать своё решение из проекта *CPP2*). Эти классы должны содержать в себе следующие методы:
    + `stack()` - создание пустого стека;
    + `queue()` - создание пустой очереди;
    + `push(value)` - добавление элемента в стек/очередь;
    + `pop()` - получение элемента из стека/очереди с его последующим удалением из стека/очереди;
    + `top()` - получение элемента из стека без его удаления из стека;
    + `front()` - получение первого элемента из очереди без его удаления из очереди;
    + `back()` - получение последнего элемента из очереди без его удаления из очереди.

*В этом и последующих заданиях считай, что номера вершин начинаются с 1.*

## Part 2. Поиск кратчайших путей в графе

* Добавь в класс `GraphAlgorithms` два новых метода:
    + `GetShortestPathBetweenVertices(Graph &graph, int vertex1, int vertex2)` - поиск кратчайшего пути между двумя вершинами в графе с использованием *алгоритма Дейкстры*. Функция принимает на вход номера двух вершин и возвращает численный результат, равный наименьшему расстоянию между ними.
    + `GetShortestPathsBetweenAllVertices(Graph &graph)` - поиск кратчайших путей между всеми парами вершин в графе с использованием *алгоритма Флойда-Уоршелла*. В качестве результата функция возвращает матрицу кратчайших путей между всеми вершинами графа.

## Part 3. Поиск минимального остовного дерева

* Добавь в класс `GraphAlgorithms` новый метод:
    + `GetLeastSpanningTree(Graph &graph)` - поиск наименьшего остовного дерева в графе с помощью *алгоритма Прима*. В качестве результата функция должна возвращать матрицу смежности для минимального остовного дерева.

## Part 4. Задача коммивояжера

* Добавь в класс `GraphAlgorithms` новый метод:
    + `SolveTravelingSalesmanProblem(Graph &graph)` - решение задачи коммивояжера с помощью *муравьиного алгоритма*. Необходимо найти самый выгодный (короткий) маршрут, проходящий через все вершины графа хотя бы по одному разу с последующим возвратом в исходную вершину. В качестве результата функция должна возвращать структуру `TsmResult`, описанную ниже:
    ```cpp
    struct TsmResult {
        int* vertices;    // массив с искомым маршрутом (с порядком обхода вершин). Вместо int* можно использовать std::vector<int>
        double distance;  // длина этого маршрута
    }
    ``` 

*Если при заданном графе решение задачи невозможно, выведи ошибку.*

## Part 5. Консольный интерфейс

* Напиши основную программу, которая представляет из себя консольное приложение для проверки работоспособности реализованных библиотек s21_graph.h и s21_graph_algorithms.h.
* Консольный интерфейс обязательно должен покрывать следующий функционал:
    1. загрузка исходного графа из файла;
    2. обход графа в ширину с выводом результата обхода в консоль;
    3. обход графа в глубину с выводом результата обхода в консоль;
    4. поиск кратчайшего пути между произвольными двумя вершинами с выводом результата в консоль;
    5. поиск кратчайших путей между всеми парами вершин в графе с выводом результирующей матрицы в консоль;
    6. поиск минимального остовного дерева в графе с выводом результирующей матрицы смежности в консоль;
    7. решение задачи комивояжера с выводом результирующего маршрута и его длины в консоль.

## Part 6. Дополнительно. Сравнение методов решения задачи коммивояжера

* Выбери дополнительные два алгоритма для решения задачи коммивояжера и реализовать их в виде методов класса `GraphAlgorithms`.
* Добавь в консольный интерфейс возможность проведения сравнительного исследования скорости работы трёх алгоритмов (муравьиного алгоритма и двух выбранных произвольно).
    + Исследование запускается для графа, который был предварительно загружен из файла.
    + В рамках исследования требуется засечь время, потраченное на решение задачи коммивояжера `N` раз подряд, каждым из алгоритмов. Где `N` задаётся с клавиатуры.
    + Необходимо вывести в консоль результаты замера времени. 

*Пример:* для `N = 1000` будет измерено сколько времени уйдёт на то, чтобы 1000 раз решить задачу коммивояжера для текущего заданного графа муравьиным алгоритмом и двумя произвольно выбранными алгоритмами.
